### 6. No DDR SD Boot

The bitstream/ELF was by far loaded via JTAG. Here, it's loaded from a SD Card, using the traditional `BOOT.BIN` method. Not a single proprietary tool is required. 

Usually, a linear memory device (like QSPI Flash) is required when doing No DDR bitstream loading. But this is not necessary. By [splitting the bitstream-loading DMA to 0xFFFFFFFF to smaller chunks](https://github.com/regymm/embeddedsw/blob/zynq_noddr/lib/sw_apps/zynq_fsbl/src/pcap.c#L312), loading from SD Card without DDR/Flash is possible with no noticeable speed difference. This can greatly ease the design of Zynq-as-MCU boards without DDR. 

#### BSP

In this case, bank voltage is set in `sdboot.py`. 

```
# Run GenZ, same as in 5-uart
$ export PYTHONPATH=../..
$ ./sdboot.py

# Prepare BSP folder for PYNQ-Z1
$ git clone https://github.com/regymm/embeddedsw --depth=1
$ cp -a embeddedsw/lib/sw_apps/zynq_fsbl/misc/{muzy4,pynqz1}
# Copy the BSP files generated by GenZ
$ cp ps7_init_sdboot/* embeddedsw/lib/sw_apps/zynq_fsbl/misc/pynqz1
```

#### FSBL and User App

Compile elf with Xilinx open source embeddedsw library (User App), enables AXI GPIO test

```
$ make BOARD=pynqz1 "CFLAGS=-DAXI_TEST" -C embeddedsw/lib/sw_apps/hello_world/src
```
Compile FSBL with No DDR SDBoot support and debug info
```
$ make BOARD=pynqz1 "CFLAGS=-DFSBL_DEBUG_INFO -DNODDR" -C embeddedsw/lib/sw_apps/zynq_fsbl/src
```
#### FPGA

Bitstream for the PL fabric can be generated with [OpenXC7](https://github.com/openXC7/), with demos at [FPGAOL-CE user-examples](https://github.com/FPGAOL-CE/user-examples/tree/main/zynq7000-demos). Makefiles for various FOSS FPGA toolchains can be generated with the [CaaS Wizard](https://github.com/FPGAOL-CE/caas-wizard). 

Without Vivado proprietary IPs, here we demonstrate a simple AXI-Lite GPIO module with a compatible register map. For complex designs with multiple AXI devices, [ZipCPU](https://github.com/ZipCPU/wb2axip/) and [alexforencich](https://github.com/alexforencich/verilog-axi) provide all required AXI interconnects, clock domain crossing, and even wishbone bridges. 

```
# With pre-generated Makefiles
$ ./run_caas.sh

# Build Makefiles from caas.conf
$ git clone https://github.com/FPGAOL-CE/caas-wizard --depth=1
$ ./caas-wizard/caasw.py mfgen --overwrite
$ ./run_caas.sh
```

#### BOOT.BIN

It's the file to put in SD card (or QSPI flash) for startup. 

```
# Prepare BOOT.BIN for SD Boot
$ git clone https://github.com/antmicro/zynq-mkbootimage --depth=1
$ make -C zynq-mkbootimage

# Prepare bif
$ cat > output.bif << EOF
the_ROM_image:
{
	[bootloader]embeddedsw/lib/sw_apps/zynq_fsbl/src/fsbl.elf
	build/top.bit
	embeddedsw/lib/sw_apps/hello_world/src/hello-world.elf
}
EOF

# Generate BOOT.BIN
$ ./zynq-mkbootimage/mkbootimage output.bif BOOT.BIN
```

#### Run

Copy BOOT.BIN to the root of the first FAT32 partition in SD Card, and power on the board with SD boot mode -- can then see LEDs blinking and PS UART output. Enjoy the freedom! 

---


#### Morale

*Why Twice?*

In Zynq development, we have great flexibility, but as a result, we often need to set the same thing multiple times -- like specifying which UART to use, specifying crystal frequency, etc. 

There're two levels of parameter specification

1. Parts that **only needs to be set once** during startup, done by ps7_init.tcl via JTAG or ps7_init.c via FSBL, including: 
   - Which MIO pins to use, like MIO 2-3 or MIO 6-7. 
   - Bank voltage, that affects MIO pin settings
   - PLL multipler/divisors
2. Parts used by software. **Each piece of software** (u-boot, Linux, etc) needs to know these. Here, the parameters back in 1. are in lower, invisible layers. In complex systems, it's usually done by device tree
   - UART0 or UART1. As they have different memory addresses. 
   - ARM core frequency, used by some timers. 
   - Size of QSPI flash
     - Of course, FSBL is also a software, and needs these. 
     - In this sense, `xparameters.h` is a small "device tree" for Xilinx embeddedsw library. 

To avoid the tedious work of configuring device trees manually for everything, **petalinux** is available. But it's usually a pain to use. Thus, the future roadmap of this project includes implementing a user-friendly petalinux alternative. 

#### Debug

Can also launch FSBL by JTAG, though it not the designed way. 

> ps7_init.tcl is used for register configuration via JTAG, while ps7_init.c has the same register configuration for FSBL. Launching FSBL by JTAG means configuration is done twice (but it doesn't matter)

E.g. in JTAG boot mode, FSBL won't run. In SD boot mode, FSBL from JTAG is executed, but it'll load bitstream and user app from SD Card! If the FSBL file size, etc is different from the one on SD card, some headers can't be read successfully. 


```
Xilinx First Stage Boot Loader 
Release 2024.1	Jan 16 2025-23:13:16
Devcfg driver initialized 
Silicon Version 3.1
Boot mode is JTAG
```